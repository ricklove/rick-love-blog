/* eslint-disable unicorn/consistent-function-scoping */
/* eslint-disable @typescript-eslint/camelcase */
/* eslint-disable unicorn/no-useless-undefined */
/* eslint-disable no-console */
import ts, { SyntaxKind, TypeAliasDeclaration } from 'typescript';
import { writeFile, watchForFileChanges, getFilename } from '../utils';


const createToGql = (sourceFile: ts.SourceFile) => {
    const sourceFilename = getFilename(sourceFile.fileName);

    // Target Generated Code:
    // const useSiteTitleStaticQuery = (): SiteTileStaticQuery => {

    //     return useStaticQuery(graphql`
    //     query SiteTileQuery {
    //       site {
    //         siteMetadata {
    //           title
    //           author
    //         }
    //       }
    //     }
    //   `);
    //   };

    const toGql_queryBodyRegex = (typeText: string): string => {
        const result = typeText
            .replace(/:\s*GatsbyImageSharpFluidFragment\s*;/g, `{...GatsbyImageSharpFluid}`)
            .replace(/\??:\s*{/g, ` {`)
            .replace(/\??:\s*(\w+\s*[,/;])/g, ``)
            .replace(/}[,;]/g, `}`)
            .replace(/\/\*/g, ``)
            .replace(/\*\//g, ``)
            .replace(/\\\\/g, ``)
            .trim();

        return result;
    };

    const isGqlNode = (node: ts.Node) => {
        if (node.kind === SyntaxKind.TypeAliasDeclaration) {
            const n = node as ts.TypeAliasDeclaration;
            const name = n.name.getFullText(sourceFile).trim();
            return name.endsWith(`StaticQuery`);
        }
        return false;
    };

    const toGql_TypeAliasDeclaration = (node: ts.TypeAliasDeclaration) => {
        // const raw = node.getFullText(sourceFile);
        // const kind = SyntaxKind[node.kind];
        const name = node.name.getFullText(sourceFile).trim();
        const typeText = node.type.getFullText(sourceFile).trim();

        if (!name.endsWith(`StaticQuery`)) {
            // Return type in case it is used 
            return `
type ${name} = ${typeText};`;
        }

        // text += `${JSON.stringify({ kind, name, typeText, raw }, undefined, 2)}\n`;

        const queryBody = toGql_queryBodyRegex(typeText);;

        return `
type ${name} = ${typeText};

export const use${name} = (): ${name} => {
    return useStaticQuery(graphql\`
        query ${name} ${queryBody}
    \`);
};`;
    };

    const toGql_ImportDeclaration = (node: ts.ImportDeclaration) => {
        const raw = node.getFullText(sourceFile).trim();
        if (raw.includes(`${sourceFilename}.gen`)) {
            return undefined;
        }

        return raw;
    };

    const toGql_Node = (node: ts.Node) => {
        if (node.kind === SyntaxKind.ImportDeclaration) {
            return toGql_ImportDeclaration(node as ts.ImportDeclaration);
        }
        if (node.kind === SyntaxKind.TypeAliasDeclaration) {
            return toGql_TypeAliasDeclaration(node as ts.TypeAliasDeclaration);
        }

        return undefined;
    };

    const toGql = () => {
        const gqlParts = sourceFile.statements.filter(x => isGqlNode(x));
        if (gqlParts.length <= 0) { return undefined; }

        const parts = sourceFile.statements.map(x => toGql_Node(x)).filter(x => x);

        // import { useStaticQuery, graphql } from 'gatsby';
        const content = `// Generated by TypeQuery
${parts.join(`\n`)}
`;
        return { filename: sourceFile.fileName, content };
    };

    return { toGql };
};


export const generateTypeQueries = (filenames: string[]) => {
    const program = ts.createProgram(filenames, {});

    const results = filenames.map((filename) => {
        const sourceFile = program.getSourceFile(filename);

        if (!sourceFile) { throw new Error(`generateTypeQueries: Could not find source file: ${filename}`); }

        const visitor = createToGql(sourceFile);
        return visitor.toGql();
    });

    return results.filter(x => x?.content);
};

export const generateTypeQuery_onFilesChanged = (filenames: string[]) => {
    const filenames_tsx = filenames.filter(x => x.endsWith(`.tsx`));

    if (filenames_tsx.length > 0) {
        console.log(`generateTypeQuery_onFilesChanged Tsx Changed`, { filenames_tsx });

        const results = generateTypeQueries(filenames_tsx);

        results.forEach(x => {
            if (!x) { return; }

            console.log(`generateTypeQuery_onFilesChanged Generated for`, { filename: x.filename });
            writeFile(`${x.filename}.gen.ts`, x.content);
        });
    }
};


export const watchFilesToGenerateTypeQuery = (pathRoot: string) => {
    watchForFileChanges({ pathRoot, runOnStart: true }, async (files) => {
        console.log(`watchFilesToGenerateTypeQuery START`, { files });
        generateTypeQuery_onFilesChanged(files);
        console.log(`watchFilesToGenerateTypeQuery DONE`);
    });
};
